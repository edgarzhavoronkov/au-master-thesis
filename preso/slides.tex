\documentclass{beamer}
\usetheme{CambridgeUS}

\usepackage{minted}
\usepackage{xcolor}
\usepackage{fontspec}
\usepackage{xunicode}
\usepackage{xltxtra}
\usepackage{xecyr}
\usepackage{hyperref}

\setmainfont[Mapping=tex-text]{CMU Serif}
\setsansfont[Mapping=tex-text]{CMU Sans Serif}                %% задаёт шрифт без засечек
\setmonofont[Mapping=tex-text]{CMU Typewriter Text}           %% задаёт моноширинный шрифт
\usepackage{polyglossia}

\setdefaultlanguage{russian}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}

\usepackage{faktor}
\usepackage{stmaryrd}

\newcommand{\alphaeq}{=_{\alpha}}
\newcommand{\betaeq}{=_{\beta}}

\begin{document}
\title[]{Реализация сравнения различных представлений \texorpdfstring{$\lambda$}{лямбда}-термов}
\author[Жаворонков Э.А.]{студент: Жаворонков Эдгар\\{\footnotesize\textcolor{gray}{научный руководитель: В.И. Исаев}}}
\institute{СПб АУ НОЦНТ РАН}
\date{13/06/2017}

\frame{\titlepage}

\begin{frame}\frametitle{Введение}
    \begin{enumerate}
        \item Программирование использует имена для того, что бы идентифицировать сущности
        \item Как следствие, в программах зачастую возникает проблема коллизий имен
        \item Чтобы доказывать свойства программ нужна формальная система, которая бы умела решать эту проблему
        \item Пример такой системы -- $\lambda$-исчисление
    \end{enumerate}
\end{frame}


\begin{frame}\frametitle{Введение(2)}
    \begin{enumerate}
        \item Термы $\lambda$-исчисления имеют несколько способов записи -- представлений
        \item Существующие работы в этой области либо формализуют только одно представление, либо устанавливают соответствие только между именованным и неименованным представлениями
        \item В отличии от них, мы рассмотрим три представления и покажем равенство между ними
    \end{enumerate}
\end{frame}


\begin{frame}\frametitle{Введение(3)}
    \begin{enumerate}
        \item Тонкость заключается в том, что именованные термы рассматриваются с точностью до $\alpha$-эквивалентности
        \item То есть мы рассматриваем фактор-множество и нам хотелось бы уметь удобно описывать их с помощью языка программирования
        \item Возникает вопрос, есть ли язык(теория типов), который позволяет просто конструировать фактор-типы?
        \item <2-> Да, есть. Он называется Vclang\only<2->\footnote{https://github.com/valis/vclang} и его теоретическая основа -- гомотопическая теория типов с типом интервала. %ссылку на статью или гитхаб?
    \end{enumerate}
\end{frame}


\begin{frame}\frametitle{Цель и задачи}
    \textbf{Цель работы} -- показать равенство между различными представлениями $\lambda$-термов.

    \bigskip

    \textbf{Задачи:}
    \begin{enumerate}
        \item Реализовать типы данных для термов в интересующих нас представлениях:
          \begin{enumerate}
            \item Именованном
            \item Неименованным
            \item Монадическим
          \end{enumerate}
        \item Для каждого представления реализовать операцию подстановки
        \item Формализовать её свойства:
          \begin{enumerate}
            \item Унитальность
            \item Ассоциативность
          \end{enumerate}
        \item Доказать, что описанные в п.1 представления равны между собой
    \end{enumerate}
\end{frame}

% плохой слайд
\begin{frame}\frametitle{Существующие решения}
    \begin{enumerate}
        \item Задача формализации $\lambda$-исчисления довольно популярна
        \item В очень большом количестве работ авторы формализуют неименованное представление
        \item Есть работы, в которых авторы сравнивают именованное и неименованное представление, но не устанавливают, что они равны
    \end{enumerate}
\end{frame}

% еще по слайду наверное надо добавить на каждое представление
\begin{frame}[fragile=singleslide]\frametitle{Решение. Именованное представление}
    Тип данных для термов:
        \begin{figure}[H]
            \center
            \begin{minted}{haskell}
            data Term =
                Var Name
                | App Term Term
                | Lam Name Term
            \end{minted}
        \end{figure}
    \begin{enumerate}
        \item Нужно разрешимое равенство на $Name$
        \item $\alpha$-эквивалентность определяется индукцией по структуре терма плюс некоторый трюк в случае абстракции
        \item Подстановка определяется через более общий случай -- параллельную подстановку
    \end{enumerate}
\end{frame}


\begin{frame}[fragile=singleslide]\frametitle{Решение. Именованное представление(2)}
    \begin{enumerate}
        \item Все утверждения о подстановке рассматривают термы с точностью до $\alpha$-эквивалентности
        \item Свойства подстановки формулируются следующим образом:
            \begin{align*}
                &x[x \mapsto t] \alphaeq t\\
                &t[x \mapsto x] \alphaeq t\\
                &t[x \mapsto N][y \mapsto M] \alphaeq t[y \mapsto M][x \mapsto N[y \mapsto M]] (x \notin FV(M))
            \end{align*}
        \item Доказываются очень нудной индукцией по структуре терма $t$
    \end{enumerate}
\end{frame}


\begin{frame}[fragile=singleslide]\frametitle{Решение. Неименованное представление}
    Термы:
    \begin{figure}[H]
            \center
            \begin{minted}{haskell}
            data Term (n : Nat) =
                Var (i : Fin n)
                | App (Term n) (Term n)
                | Lam (Term (suc n))
            \end{minted}
        \end{figure}
    \begin{enumerate}
        \item Здесь $n$ -- длина контекста, в котором определен терм, а $i$ -- индекс переменной в нем
        \item Подстановка в таком представлении -- полная(во все переменные)
        \item Так как нет имен переменных, то и определяется она намного проще
    \end{enumerate}
\end{frame}


\begin{frame}[fragile=singleslide]\frametitle{Решение. Монадическое представление}
    Термы:
    \begin{figure}[H]
            \center
            \begin{minted}{haskell}
            data Term (V : Set) =
                Var V
                | App (Term V) (Term V)
                | Lam (Term (Maybe V))
            \end{minted}
        \end{figure}
    \begin{enumerate}
        \item Нетрудно заметить, что это функтор
        \item Чуть менее очевидно, но это монада
        \item \texttt{fmap} -- переименовывает переменные в терме, а ($>>=$) -- это, внезапно, подстановка
        \item Монадные законы в точности описывают свойства подстановки
    \end{enumerate}
\end{frame}


\begin{frame}[fragile=singleslide]\frametitle{Решение. Монадическое представление(2)}
    \begin{enumerate}
        \item Чтобы доказать, что это монада заметим, что есть два способа определить $>>=$
          \begin{enumerate}
            \item По стрелке Клейсли $k : V \to Term\ W$ построить стрелку Клейсли $k : (V + 1) \to Term\ (W + 1)$
            \item Обобщить сигнатуру $>>= : Term\ V \to (V \to Term\ W) \to Term\ W$ до $>>=' : Term\ (V + n) \to (V \to Term\ W) \to Term\ (W + n)$
          \end{enumerate}
        \item Второй менее удобен, так как всплывают взаимно-рекурсивные определения, с которыми неудобно работать.
    \end{enumerate}
\end{frame}


\begin{frame}[fragile=singleslide]\frametitle{Решение. Равенства между представлениями}
    TODO:
    \begin{enumerate}
        \item
        \item
        \item
    \end{enumerate}
\end{frame}


\begin{frame}\frametitle{Результаты}
    \begin{enumerate}
        \item Написаны преобразования:
            \begin{enumerate}
                \item Из именованных термов в неименованные.
                \item Из неименованных в монадические.
                \item И обратно.
            \end{enumerate}
        \item Доказано, что преобразования -- биекции.
        \item Для именованных термов описана $\alpha$-эквивалентность.
        \item Для каждого представления определена операция подстановки.
        \item Для каждого представления доказаны свойства термов:
            \begin{enumerate}
                \item Преобразование именованного терма в неименованный уважает $\alpha$-эквивалентность.
                \item Свойства операции подстановки.
            \end{enumerate}
    \end{enumerate}
\end{frame}

\begin{frame}\frametitle{Недостатки}
    TODO: может на этом слайде про планы развития написать? Или про них на предыдущем слайде сказать?
    \begin{enumerate}
        \item
        \item
        \item
        \item
        \item
    \end{enumerate}
\end{frame}

\begin{frame}\frametitle{fin}
    \begin{center}
        \Huge Спасибо за внимание! \\ Вопросы?
    \end{center}

    \begin{block}{Github repo:}
        \footnotesize{https://github.com/edgarzhavoronkov/vclang-lib/tree/lambda\_calculus/test/LC}
    \end{block}
\end{frame}


\end{document}
