\subsection{Монадическое представление термов}
\label{sec:monad}
Существует еще один способ записи $\lambda$-термов, описанный в \cite{bird1999bruijn}. Библиотека \textbf{Bound}~\cite{bound} для языка \textbf{Haskell}, например, использует именно монадическое представление.

Основная идея в том, что именованное представление для термов можно обобщить и свободные переменные брать из произвольного множества $V$. Тогда множество термов $\Lambda_{V}$ определяется индуктивно по следующим правилам:
\begin{center}
  \AxiomC{$v \in V$}
  \UnaryInfC{$v \in \Lambda_{V}$}
  \DisplayProof{}
\end{center}

\begin{center}
  \AxiomC{$M \in \Lambda_{V}$}
  \AxiomC{$N \in \Lambda_{V}$}
  \BinaryInfC{$M N \in \Lambda_{V}$}
  \DisplayProof{}
\end{center}

\begin{center}
  \AxiomC{$M \in \Lambda_{V \coprod \{*\}}$}
  \UnaryInfC{$\lambda M \in \Lambda_{V}$}
  \DisplayProof{}
\end{center}

Здесь $\{*\}$ -- это произвольное одноэлементное множество, а $\coprod$ -- операция размеченного объединения множеств. По определению $A \coprod B$ состоит из элементов $inl(a)$ и $inr(b)$, где $a \in A$ и $b \in B$.  Так как для абстракции нам нужно иметь на одну свободную переменную больше, то ее можно получить взяв размеченное объединение с произвольным одноэлементным множеством. Это представление так же удобно для компьютерной реализации за счет того, что проверку корректности построения термов можно выполнять на уровне типов.

Пусть у нас есть функция $f : V \to W$, тогда мы можем задать функцию $F_{f}$ из $\Lambda_{V}$ в $\Lambda_{W}$ рекурсией по терму $T \in \Lambda_{V}$:

\begin{enumerate}
  \item $v \mapsto f(v)$
  \item $M\ N \mapsto F_{f}(M)\ F_{f}(N)$
  \item $\lambda M \mapsto \lambda F_{f'(f)}(M)$. Заметим, что просто так отобразить терм $M$ с помощью функции $f$ мы не можем, так как ее домен не совпадает со множеством, которым параметризован тип терма $M$. Поэтому мы построим по $f$ функцию $f'(f) : V \coprod \{*\} \to W \coprod \{*\}$. Устроена она будет следующим образом:
  \begin{enumerate}
    \item $f'(f)(inl(x)) = inl(f(x))$
    \item $f'(f)(inr(*)) = inr(*)$
  \end{enumerate}
\end{enumerate}

Знакомый с языком программирования \textbf{Haskell} или теорией категорий читатель узнает, что мы задали структуру функтора. Интуитивно, действие этого функтора -- это переименование переменных. Покажем, что это действительно функтор, именно, что он уважает тождественное отображение и композицию отображений.

\begin{prop}
  \label{monad:fmap-resp-id}
  Для любого $T \in \Lambda_{V}$ верно, что $F_{id_{V}}(T) = T$
\end{prop}

\begin{proof}
  Индукция по терму $T$. База тривиальна, равно как и случай аппликации, покажем, что утверждение верно и для случая лямбды. Вспомогательная функция $f'(f)$ устроена следующим образом:
  \begin{enumerate}
    \item $f'(id_{V})(inl(x)) = inl(x)$
    \item $f'(id_{V})(inr(*)) = inr(x)$
  \end{enumerate}
  Следовательно, оно является тождеством на $V \coprod \{*\}$. По индукционной гипотезе получаем, что случай для лямбды тоже верен.

  Формальное доказательство этого утверждения можно увидеть в приложении~\ref{apendix:monad}, в функции \texttt{fmap-respects-id}
\end{proof}

\begin{prop}
  \label{monad:fmap-resp-comp}
  Для любого $T \in \Lambda_{V}$ и $f : V \to W$, $g : W \to X$ верно, что $F_{g \circ f}(T) = F_{g}(T) \circ F_{f}(T)$
\end{prop}

\begin{proof}
  Снова индукция по терму $T$. Случай переменной снова тривиален, случай аппликации напрямую следует из индукционной гипотезы, рассмотрим случай абстракции. Посмотрим, во что вычислится левая часть:
  \begin{gather*}
    F_{g \circ f}(\lambda M) = \lambda F_{f'(g \circ f)}(M) \\
    \text{где} \\
    f'(g \circ f)(inl(v)) = inl(g(f(v))) \\
    f'(g \circ f)(inr(*)) = inr(*)
  \end{gather*}

  Правая, в свою очередь:
  \begin{gather*}
    F_{g}(F_{f}(\lambda M)) = F_{g}(\lambda F_{f'(f)}(M)) = \\
    \lambda F_{g'(g)}(F_{f'(f)}(M))
  \end{gather*}

  Вспомогательная функция $f'(f) : V \coprod \{*\} \to W \coprod \{*\}$ устроена здесь следующим образом:
  \begin{enumerate}
    \item $f'(f)(inl(v)) = inl(f(v))$
    \item $f'(f)(inr(*)) = inr(*)$
  \end{enumerate}

  Вспомогательная функция $g'(g) : W \coprod \{*\} \to X \coprod \{*\}$ устроена здесь следующим образом:
  \begin{enumerate}
    \item $g'(g)(inl(w)) = g'(g)(inl(f(v))) = inl(g(f(v)))$
    \item $g'(g)(inr(*)) = inr(*)$
  \end{enumerate}

  Несложно увидеть, что эти две функции из левой и правой частей ведут себя одинаково, следовательно и для случая лямбды утверждение верно.
  Формальное доказательство этого утверждения можно увидеть в приложении~\ref{apendix:monad}, в функции \texttt{fmap-respects-сomp}
\end{proof}

Мы пойдем еще дальше и зададим структуру монады. Существует много способов определить её, мы воспользуемся тем, который принят в языке программирования \textbf{Haskell}. Именно, мы определим две операции: монадическую единицу $\texttt{return} : V \to \Lambda_{V}$ и монадическое связывание $\texttt{bind} : \Lambda_{V} \to (V \to \Lambda_{W}) \to \Lambda_{W}$. Кроме этого, мы покажем, что они удовлетворяют монадическим законам.

Монадическая единица устроена очень просто -- это переменная. Связывание же, принимает на вход так называемую стрелку Клейсли~\cite{kleisliArrows} $k : V \to \Lambda_{W}$ и определяется индуктивно по структуре терма $T$:

\begin{enumerate}
  \item $v \mapsto k(v)$
  \item $M\ N \mapsto (\texttt{bind}(M, k))\ (\texttt{bind}(N, k))$
  \item $\lambda M \mapsto \lambda(\texttt{bind}(M, k'(k)))$, где $k'(k) : V \coprod \{*\} \to \Lambda_{W \coprod \{*\}}$ и определяется следующим образом:
    \begin{enumerate}
      \item $k'(k)(inl(v)) = F_{inl}(k(v))$
      \item $k'(k)(inr(*)) = \texttt{return}(inr(*))$
    \end{enumerate}
\end{enumerate}


Сформулируем и докажем теперь свойства этих двух операций.

\begin{prop}
  \label{monad:bind-right-unit}
  Для любого $T \in \Lambda_{V}$ верно $\texttt{bind}(T, \texttt{return}) = T$.
\end{prop}

\begin{proof}
  Индукция по структуре терма $T$:
  \begin{enumerate}
    \item База индукции, $T = v$. Имеем, что $\texttt{bind}(v, \texttt{return}) = \texttt{return}(v) = v$.
    \item Случай аппликации напрямую следует из предположения индукции.
    \item Пусть теперь $T = \lambda M$. Имеем, что $\texttt{bind}(\lambda M, \texttt{return}) = \lambda (\texttt{bind}(M, k'(\texttt{return})))$. Вспомогательное отображение $k'(return)$ устроено следующим образом:
    \begin{enumerate}
      \item $k'(\texttt{return})(inl(v)) = F_{inl}(\texttt{return}(v)) = \texttt{return}(inl(v))$
      \item $k'(\texttt{return})(inr(*)) = \texttt{return}(inr(*))$
    \end{enumerate}
  \end{enumerate}

  Заметим, что оно ведет себя так же, как и \texttt{return} на $V \coprod \{*\}$, следовательно по индукционной гипотезе получаем исходное утверждение.
  Формальное доказательство этого утверждения можно увидеть в приложении~\ref{apendix:monad}, в функции \texttt{bind-right-unit}.
\end{proof}

\begin{prop}
  \label{monad:bind-left-unit}
  Для любого $v \in V$ и $k : V \to \Lambda_{V}$ верно $\texttt{bind}(\texttt{return}(v), k) = k(v)$
\end{prop}

\begin{proof}
  Утверждение тривиально следует из определения \texttt{bind} и того факта, что \texttt{return} -- это переменная. Формальное доказательство этого утверждения можно увидеть в приложении~\ref{apendix:monad}, в функции \texttt{bind-left-unit}.
\end{proof}

Прежде, чем формулировать последний монадный закон, сформулируем и докажем несколько технических лемм, которые помогут нам в его доказательстве.

\begin{lemma}
  \label{monad:bind-fmap-comm-lhs}
  Для любых $T \in \Lambda_{V}$, $f : V \to W$ и $k : W \to \Lambda_{U}$ верно $\texttt{bind}(F_{f}(T), k) = \texttt{bind}(T, k \circ f)$.
\end{lemma}

\begin{proof}
  Индукция по структуре терма $T$ с тривиальными случаями переменной и аппликации. Рассмотрим случай абстракции $\lambda M$. Нам нужно показать, что $\lambda \texttt{bind}(F_{f'(f)}(M), k'(k)) = \lambda \texttt{bind}(M, k'(k \circ f))$. По индукционной гипотезе мы знаем, что $\texttt{bind}(F_{f'(f)}(M), k'(k)) = \texttt{bind}(M, k'(k) \circ f'(f))$, Заметим теперь, что $k'(k \circ f)$ и $k'(k) \circ f'(f)$ ведут себя одинаково на всех входах, следовательно это утверждение доказано. Формальное доказательство этого утверждения можно увидеть в приложении~\ref{apendix:monad}, в функции \texttt{bind-fmap-comm-lhs}.
\end{proof}

\begin{lemma}
  \label{monad:bind-fmap-comm-rhs}
  Для любых $T \in \Lambda_{V}$, $f : W \to U$ и $k : V \to \Lambda_{W}$ верно $ F_{f}(\texttt{bind}(T, k)) = \texttt{bind}(T, (x \mapsto F_{f}(k(x))))$.
\end{lemma}

\begin{proof}
  Снова индукция по структуре терма $T$. Случай переменной и аппликации снова тривиален, поэтому рассмотрим случай абстракции $\lambda M$.

  Нам нужно показать, что $\lambda F_{f'(f)}(\texttt{bind}(M, k'(k))) = \lambda \texttt{bind}(M, k'(x \mapsto F_{f}(k(x))))$. По индукционной гипотезе мы знаем, что $F_{f'(f)}(\texttt{bind}(M, k'(k))) = \texttt{bind}(M, (x \mapsto F_{f'(f)}(k'(k)(x))))$. Покажем теперь, что стрелки Клейсли $ k'(x \mapsto F_{f}(k(x))) $ и $ x \mapsto F_{f'(f)}(k'(k)(x)) $ ведут себя одинаково на всех входах:

  \begin{enumerate}
    \item $inr(*)$. Обе стрелки вычисляются в $\texttt{return}(inr(*))$
    \item $inl(v)$. Надо показать, что $F_{f'(inl)}(F_{f}(k(v))) = F_{f'(f)}(F_{inl}(k(v)))$. Так как $\Lambda_{-}$ -- функтор и он уважает композицию отображений имеем, что нужно показать $F_{f'(inl) \circ f}(k(v)) = F_{f'(f) \circ inl}(k(v))$. Для этого в свою очередь нужно снова показать, что два отображения $f'(inl) \circ f$ и $f'(f) \circ inl$ ведут себя одинаково на всех входах, но это очень легко понять, просто взглянув на определение $f'$.
  \end{enumerate}

  Формальное доказательство этого утверждения можно увидеть в приложении~\ref{apendix:monad}, в функции \texttt{bind-fmap-comm-rhs}.
\end{proof}

\begin{lemma}
  \label{monad:bind-fmap-comm}
  Для любого $T \in \Lambda_{V}$ и $f : V \to \Lambda_{W}$ верно $\texttt{bind}(F_{inl}(t), k'(g)) = F_{inl}(\texttt{bind}(T, f))$.
\end{lemma}

\begin{proof}
  Снова индукция по структуре терма $T$, случай переменной и аппликации тривиален, рассмотрим случай абстракции $\lambda M$.

  Левая часть вычислится в:
  $$ \lambda F_{f'(inl)}(\texttt{bind}(M, k'(f))) $$
  Правая в:
  $$ \lambda \texttt{bind}(F_{f'(inl)}(M), k'(k'(f))) $$

  По лемме~\ref{monad:bind-fmap-comm-lhs} имеем, что $\texttt{bind}(F_{f'(inl)}(M), k'(k'(f))) = \texttt{bind}(M, k'(k'(f)) \circ f'(inl))$. По лемме~\ref{monad:bind-fmap-comm-rhs} имеем $F_{f'(inl)}(\texttt{bind}(M, k'(f))) = \texttt{bind}(M, (x \mapsto F_{f'(inl)}(k'(f)(x))))$. Заметим теперь, что стрелки Клейсли $k'(k'(f)) \circ f'(inl)$ и $x \mapsto F_{f'(inl)}(k'(f)(x))$ ведут себя одинаково на всех входах, тогда по симметричности и транзитивности равенства получаем доказательство требуемого утверждения.

  Формальное доказательство этого утверждения можно увидеть в приложении~\ref{apendix:monad}, в функции \texttt{bind-fmap-comm}.
\end{proof}

\begin{prop}
  \label{monad:bind-assoc}
  Для любого $T \in \Lambda_{V}$, $f : V \to \Lambda_{W}, g : W \to \Lambda_{U}$ верно $\texttt{bind}(\texttt{bind}(T, f), g) = \texttt{bind}(T, (x \mapsto \texttt{bind}(f(x), g)) )$.
\end{prop}

\begin{proof}
  Индукция по терму $T$:
  \begin{enumerate}
    \item Рассмотрим случай, когда $T = v$. Тогда левая часть вычисляется в $\texttt{bind}(f(v), g)$, ровно как и правая.
    \item Случай для аппликации следует напрямую из индукционной гипотезы.
    \item Рассмотрим случай абстракции $\lambda M$. Посмотрим, во что вычисляется левая часть:
    \begin{gather*}
      \texttt{bind}(\texttt{bind}(\lambda M, f), g) = \texttt{bind}(\lambda \texttt{bind}(M, k'(f)), g) = \\
      \lambda \texttt{bind}(\texttt{bind}(M, k'(f)), k'(g)) \\
      \text{где} \\
      k'(g)(inl(w)) = F_{inl}(g(w)) \\
      k'(g)(inr(*)) = \texttt{return}(inr(*)) \\
      \text{и} \\
      k'(f)(inl(v)) = F_{inl}(f(v)) \\
      k'(f)(inr(*)) = \texttt{return}(inr(*))
    \end{gather*}

    Правая часть, в свою очередь, вычисляется в:
    \begin{gather*}
      \texttt{bind}(\lambda M, (x \mapsto \texttt{bind}(f(x), g))) = \lambda \texttt{bind}(M, k'(x \mapsto \texttt{bind}(f(x), g)))
    \end{gather*}

    Чтобы воспользоваться индукционной гипотезой, необходимо показать, что $k'(x \mapsto \texttt{bind}(f(x), g)) : V \coprod \{*\} \to \Lambda_{U \coprod \{*\}}$ ведет себя так же как и $x \mapsto \texttt{bind}(k'(f)(x), k'(g))$. Для этого мы просто покажем, что они возвращают одинаковый результат на всех входах.

    Рассмотрим два случая, как могут выглядеть входные данные:
    \begin{enumerate}
      \item $inr(*)$. Обе части вычисляются в $\texttt{return}(inr(*))$.
      \item $inl(v)$. Левая часть вычисляется в: $$ F_{inl}(\texttt{bind}(f(v), g)) $$
      Правая: $$\texttt{bind}(F_{inl}(f(v)), f'(g))$$
      Воспользовавшись леммой~\ref{monad:bind-fmap-comm} для терма $f(v)$ и $g$ получаем доказательство исходного утверждения. \qedhere
    \end{enumerate}
  \end{enumerate}

  Формальное доказательство этого утверждения можно увидеть в приложении~\ref{apendix:monad}, в функции \texttt{bind-assoc}.
\end{proof}


Отметим наконец, что действие функтора мы проинтерпретировали, как переименование переменных. Действие монадического связывания можно, в таком случае, проинтерпретировать как подстановку. Это утверждение не столь очевидно, но если рассмотреть сигнатуру \texttt{bind} и обратить внимание на то, что функцию $k : V \to \Lambda_{W}$ можно задать в виде списка пар $(V, \Lambda_{W})$, то это соответствие становится куда более явным. Монадные законы, в свою очередь, в точности описывают свойства подстановки, которые мы в явном виде задали в прошлых разделах~\ref{sec:named} и \ref{sec:index}.
