\subsection{Монадическое представление термов}

Существует еще один способ записи $\lambda$-термов, описанный в \cite{bird1999bruijn}. Библиотека \textbf{Bound}~\cite{bound} для языка \textbf{Haskell}, например, использует именно монадическое представление.

Но сперва нам понадобится несколько определений из теории категорий.

% Нам понадобится несколько определений, на тот случай, если читатель не знаком с языком программирования \textbf{Haskell}.
%
% \begin{definition}
%   Класс типов -- это именованный набор имён функций, сигнатуры которых параметризованы общим типовым параметром.
% \end{definition}
%
% О классах типов можно думать, как об интерфейсах в императивных языках программирования. Не предоставляя никакой реализации, они тем не менее специфицируют поведение.
%
% \begin{definition}
%   Тип $F$ называется функтором, если для него определена операция
% \end{definition}

\begin{definition}
  \textbf{Категория} $\mathfrak{C}$ состоит из:
  \begin{enumerate}
    \item Коллекции объектов - $Ob(\mathfrak{C})$
    \item Коллекции морфизмов- $Hom_{\mathfrak{C}}(A, B)$ для любых объектов $A, B \in Ob(\mathfrak{C})$. Морфизм $f \in Hom_{\mathfrak{C}}(A, B)$ мы будем обозначать $f : A \to B$.
    \item Операции, сопоставляющей каждому объекту $A \in Ob(\mathfrak{C})$ тождественный морфизм $id_{A} : A \to A$.
    \item Операции, сопоставляющей двум морфизмам $f : A \to B$ и $g : B \to C$ морфизм $g \circ f : A \to C$, называемым композицией. Композиция должна удовлетворять следующим свойствам:
      \begin{itemize}
        \item $f \circ id_{A} = f$
        \item $id_{B} \circ f = f$
        \item $h \circ (g \circ f) = (h \circ g) \circ f$
      \end{itemize}
  \end{enumerate}
\end{definition}

\begin{definition}
  \textbf{Функтор} между категориями $\mathfrak{C}$ и $\mathfrak{D}$ состоит из двух отображений:
  \begin{enumerate}
    \item Между объектами - $F : Ob(\mathfrak{C}) \to Ob(\mathfrak{D})$
    \item И между морфизмами - $F : Hom_{\mathfrak{C}}(A, B) \to Hom_{\mathfrak{D}}(F(A), F(B))$
  \end{enumerate}

  И удовлетворяет свойствам:
  \begin{enumerate}
    \item $F(id_{A}) = id_{F(A)}$
    \item $F(g \circ f) = F(g) \circ F(f)$
  \end{enumerate}
\end{definition}

О функторах можно думать, как об отображениях между категориями, которые не меняют их структуру. Можно определить понятие морфизма между функторами -- естественного преобразования:

\begin{definition}
  Пусть $F, G : \mathfrak{C} \to \mathfrak{D}$ два функтора. Функция $\alpha : F \to G$, называется \textbf{естественным преобразованием} и сопоставляет каждому объекту $X \in Ob(\mathfrak{C})$ морфизм $\alpha_{X} : F(X) \to G(X)$, такой что диаграмма ниже коммутирует:

  \begin{displaymath}
    \xymatrix{
      F(X) \ar[r]^{\alpha_{X}} \ar[d]_{F(f)} & G(X) \ar[d]^{G(f)}\\
      F(Y) \ar[r]^{\alpha_{Y}} & G(Y)
    }
  \end{displaymath}
\end{definition}

И, наконец, определение монады:

\begin{definition}
  \textbf{Монада} $T$ на категории $\mathfrak{C}$ -- это функтор $T : \mathfrak{C} \to \mathfrak{C}$ и два естественных преобразования: $\eta_{A} : A \to T(A)$ и $\mu_{A} : T(T(A)) \to T(A)$, удовлетворяющих свойствам:

  \begin{displaymath}
    \xymatrix{ TTT(A) \ar[r]^{T(\mu_A)} \ar[d]_{\mu_{T(A)} } & TT(A) \ar[d]^{\mu_A} \\
                TT(A) \ar[r]_{\mu_A}                         & T(A)
              }
  \quad
     \xymatrix{ T(A) \ar[r]^{\eta_{T(A)}} \ar[rd]_{id_{T(A)}} & TT(A) \ar[d]^{\mu_A} & T(A) \ar[l]_{T(\eta_A)} \ar[dl]^{id_{T(A)}} \\
                                                              & T(A)
              }
  \end{displaymath}
\end{definition}

Знакомый с языком программирования \textbf{Haskell} читатель узнает в этих естественных преобразованиях операции \textit{return} и \textit{join} из класса типов \textit{Monad}, 

Основная идея в том, что именованное представление для термов можно обобщить и свободные переменные брать из произвольного множества $V$. Тогда множество термов $\Lambda_{V}$ определяется индуктивно по следующим правилам:
\begin{align*}
  v \in V &\Rightarrow v \in \Lambda_{V} \\
  M, N \in \Lambda_{V} &\Rightarrow M N \in \Lambda_{V} \\
  M \in \Lambda_{V \coprod \{*\}} &\Rightarrow \lambda M \in \Lambda_{V}
\end{align*}
