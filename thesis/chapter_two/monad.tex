\subsection{Монадическое представление термов}

Существует еще один способ записи $\lambda$-термов, описанный в \cite{bird1999bruijn}. Библиотека \textbf{Bound}~\cite{bound} для языка \textbf{Haskell}, например, использует именно монадическое представление.

Основная идея в том, что именованное представление для термов можно обобщить и свободные переменные брать из произвольного множества $V$. Тогда множество термов $\Lambda_{V}$ определяется индуктивно по следующим правилам:
\begin{center}
  \AxiomC{$v \in V$}
  \UnaryInfC{$v \in \Lambda_{V}$}
  \DisplayProof{}
\end{center}

\begin{center}
  \AxiomC{$M \in \Lambda_{V}$}
  \AxiomC{$N \in \Lambda_{V}$}
  \BinaryInfC{$M N \in \Lambda_{V}$}
  \DisplayProof{}
\end{center}

\begin{center}
  \AxiomC{$M \in \Lambda_{V \coprod \{*\}}$}
  \UnaryInfC{$\lambda M \in \Lambda_{V}$}
  \DisplayProof{}
\end{center}

Здесь $\{*\}$ -- это произвольное одноэлементное множество, а $\coprod$ -- операция размеченного объединения множеств. По определению $A \coprod B$ состоит из элементов $inl(a)$ и $inr(b)$, где $a \in A$ и $b \in B$.  Так как для абстракции нам нужно иметь на одну свободную переменную больше, то ее можно получить взяв размеченное объединение с произвольным одноэлементным множеством.

Пусть у нас есть функция $f : V \to W$, тогда мы можем задать функцию $F_{f}$ из $\Lambda_{V}$ в $\Lambda_{W}$ рекурсией по терму $T \in \Lambda_{V}$:

\begin{enumerate}
  \item $v \mapsto f(v)$
  \item $M\ N \mapsto F_{f}(M)\ F_{f}(N)$
  \item $\lambda M \mapsto \lambda F_{f'(f)}(M)$. Заметим, что просто так отобразить терм $M$ с помощью функции $f$ мы не можем, так как ее домен не совпадает со множеством, которым параметризован тип терма $M$. Поэтому мы построим по $f$ функцию $f'(f) : V \coprod \{*\} \to W \coprod \{*\}$. Устроена она будет следующим образом:
  \begin{enumerate}
    \item $f'(f)(inl(x)) = inl(f(x))$
    \item $f'(f)(inr(*)) = inr(*)$
  \end{enumerate}
\end{enumerate}

Знакомый с языком программирования \textbf{Haskell} или теорией категорий читатель узнает, что мы задали структуру функтора. Интуитивно, действие этого функтора -- это переименование переменных. Покажем, что это действительно функтор, именно, что он уважает тождественное отображение и композицию отображений.

\begin{prop}
  Для любого $T \in \Lambda_{V}$ верно, что $F_{id_{V}}(T) = T$
\end{prop}

\begin{proof}
  Индукция по терму $T$. База тривиальна, равно как и случай аппликации, покажем, что утверждение верно и для случая лямбды. Вспомогательная функция $f'(f)$ устроена следующим образом:
  \begin{enumerate}
    \item $f'(id_{V})(inl(x)) = inl(x)$
    \item $f'(id_{V})(inr(*)) = inr(x)$
  \end{enumerate}
  Следовательно, оно является тождеством на $V \coprod \{*\}$. По идукционной гипотезе получаем, что случай для лямбды тоже верен.
\end{proof}

\begin{prop}
  Для любого $T \in \Lambda_{V}$ и $f : V \to W$, $g : W \to X$ верно, что $F_{g \circ f}(T) = F_{g}(T) \circ F_{f}(T)$
\end{prop}

\begin{proof}
  Снова индукция по терму $T$. Случай переменной снова тривиален, случай аппликации напрямую следуюет из индукционной гипотезы, рассмотрим случай абстракци. Посмотрим, во что вычислится левая часть:
  \begin{gather*}
    F_{g \circ f}(\lambda M) = \lambda F_{f'(g \circ f)}(M) \\
    \text{где} \\
    f'(g \circ f)(inl(v)) = inl(g(f(v))) \\
    f'(g \circ f)(inr(*)) = inr(*)
  \end{gather*}

  Правая, в свою очередь:
  \begin{gather*}
    F_{g}(F_{f}(\lambda M)) = F_{g}(\lambda F_{f'(f)}(M)) = \\
    \lambda F_{g'(g)}(F_{f'(f)}(M))
  \end{gather*}

  Вспомогательная функция $f'(f) : V \coprod \{*\} \to W \coprod \{*\}$ устроена здесь следующим образом:
  \begin{enumerate}
    \item $f'(f)(inl(v)) = inl(f(v))$
    \item $f'(f)(inr(*)) = inr(*)$
  \end{enumerate}

  Вспомогательная функция $g'(g) : W \coprod \{*\} \to X \coprod \{*\}$ устроена здесь следующим образом:
  \begin{enumerate}
    \item $g'(g)(inl(w)) = g'(g)(inl(f(v))) = inl(g(f(v)))$
    \item $g'(g)(inr(*)) = inr(*)$
  \end{enumerate}

  Несложно увидеть, что эти две функции из левой и правой частей ведут себя одинаково, следовательно и для случая лямбды утверждение верно.
\end{proof}

Мы пойдем еще дальше и зададим структуру монады. Существует много способов определить её, мы воспользуемся тем, который принят в языке программирования \textbf{Haskell}. Именно, мы определим две операции: монадическую единицу $\texttt{return} : V \to \Lambda_{V}$ и монадическое связывание $\texttt{bind} : \Lambda_{V} \to (V \to \Lambda_{W}) \to \Lambda_{W}$. Кроме этого, мы покажем, что они удовлетворяют монадическим законам.

Монадическая единица устроена очень просто -- это переменная. Связывание же, принимает на вход так называемую стрелку Клейсли~\cite{kleisliArrows} $k : V \to \Lambda_{W}$ и определяется индуктивно по структуре терма $T$:

\begin{enumerate}
  \item $v \mapsto k(v)$
  \item $M\ N \mapsto (\texttt{bind}(M, k))\ (\texttt{bind}(N, k))$
  \item $\lambda M \mapsto \lambda(\texttt{bind}(M, k'(k)))$, где $k'(k) : V \coprod \{*\} \to \Lambda_{W \coprod \{*\}}$ и определяется следующим образом:
    \begin{enumerate}
      \item $k'(k)(inl(v)) = F_{inl}(k(v))$
      \item $k'(k)(inr(*)) = \texttt{return}(inr(*))$
    \end{enumerate}
\end{enumerate}


Сформулируем и докажем теперь свойства этих двух операций.

\begin{prop}
  Для любого $T \in \Lambda_{V}$ верно $\texttt{bind}(T, \texttt{return}) = T$
\end{prop}

\begin{proof}
  Индукция по структуре терма $T$:
  \begin{enumerate}
    \item База индукции, $T = v$. Имеем, что $\texttt{bind}(v, \texttt{return}) = \texttt{return}(v) = v$.
    \item Cлучай аппликации напрямую следует из предположения индукции.
    \item Пусть теперь $T = \lambda M$. Имеем, что $\texttt{bind}(\lambda M, \texttt{return}) = \lambda (\texttt{bind}(M, k'(\texttt{return})))$. Вспомогательное отображение $k'(return)$ устроено следующим образом:
    \begin{enumerate}
      \item $k'(\texttt{return})(inl(v)) = F_{inl}(v) = inl(v)$
      \item $k'(\texttt{return})(inr(*)) = \texttt{return}(inr(*))$
    \end{enumerate}
  \end{enumerate}

  Заметим, что оно ведет себя так же, как и \texttt{return} на $V \coprod \{*\}$, следовательно по индукционной гипотезе получаем исходное утверждение.
\end{proof}

\begin{prop}
  Для любого $v \in V$ и $k : V \to \Lambda_{V}$ верно $\texttt{bind}(\texttt{return}(v), k) = k(v)$
\end{prop}

\begin{proof}
  Утверждение тривиально следует из определения \texttt{bind} и того факта, что \texttt{return} -- это переменная.
\end{proof}

\begin{prop}
  Для любого $T \in \Lambda_{V}$, $f : V \to \Lambda_{W}, g : W \to \Lambda_{U}$ верно $\texttt{bind}(\texttt{bind}(T, f), g) = \texttt{bind}(T, f')$, где $f'(x) = \texttt{bind}(f(x), g)$
\end{prop}

\begin{proof}
  Индукция по терму $T$:
  \begin{enumerate}
    \item Рассмотрим случай, когда $T = v$. Тогда левая часть вычисляется в $\texttt{bind}(f(v), g)$, ровно как и правая.
    \item Случай для аппликации следует напрямую из индукционной гипотезы.
    \item Рассмотрим случай абстракции $\lambda M$
  \end{enumerate}
\end{proof}


Отметим наконец, что действие функтора мы проинтерпретировали, как переименование переменных. Действие монадического связывания можно, в таком случае, проинтерпретировать как подстановку. Это утверждение не столь очевидно, но если рассмотреть сигнатуру \texttt{bind} и обратить внимание на то, что функцию $k : V \to \Lambda_{W}$ можно задать в виде списка пар $(V, \Lambda_{W})$, то это соответствие становится куда более явным. Монадные законы, в свою очередь, в точности описывают свойства подстановки, которые мы в явном виде задали в прошлых разделах~\ref{sec:named} и \ref{sec:index}.
