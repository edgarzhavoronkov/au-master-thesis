\subsection{Описание языка Vclang}

% Второе предложение очень плохое. Перепиши.
Для реализации всех описанных во второй главе представлений был выбран язык \textbf{Vclang}. В этом подразделе мы кратко опишем его отличия от известных систем автоматического доказательства теорем, например \textbf{Agda}, которые привели к тому, что именно \textbf{Vclang} был выбран в качестве инструмента.

Язык \textbf{Vclang} разрабатывается в компании JetBrains с февраля 2015 года в рамках исследования в группе гомотопической теории типов и зависимых типов\footnote{https://research.jetbrains.org/ru/groups/group-for-dependent-types-and-hott}. Он представляет собой функциональный язык программирования, основанный на гомотопической теории типов с типом интервала. Компилятор языка написан полностью на \textbf{Java}, что позволяет полностью использовать все преимущества платформы \textbf{JVM}, как-то кроссплатформенность, легкость в инструментировании и возможность разрабатывать модули на языках программирования, совместимых с платформой \textbf{JVM}(например на \textbf{Scala} или \textbf{Kotlin}).

\textbf{Vclang} позволяет определять и пользоваться многими знакомыми конструкциями, как то:
\begin{enumerate}
  \item Индуктивные типы данных(как и в упрощенном синтаксисе, так и в синтаксисе обобщенных алгебраических типов данных)
  \item Сопоставление с образцом
  \item Метапеременные
  \item Неявные аргументы функций
  \item Проверка на завершаемость(termination checking)
\end{enumerate}

Последний пункт означает примерно следующее. Так как задача проверки типа в такой системе должна быть разрешима, то все вычисления в типах должны завершаться. Это, в свою очередь, означает, что все функции, которые определяет программист должны завершаться на всех входах, то есть быть всюду определенными. Проверка на завершаемость и означает, что среди прочих особенностей, в языке есть компонент, который проверяет, действительно ли все функции завершаются на всех входах. Это приводит к тому, что конструкции приходится определять так, чтобы вычислителю было очевидно, что они завершаются. При этом с точки зрения программиста, эти конструкции из простых и понятных могут превратиться в неочевидные.

С точки зрения синтаксиса, \textbf{Vclang} имеет общие черты с \textbf{Agda} или \textbf{Haskell}, кроме нескольких особенностей. Во-первых, ключевые слова языка начинаются с обратной косой черты(\textbackslash{}data, \textbackslash{}function и так далее), во-вторых, \textbf{Vclang} не использует Unicode-обозначения и миксфиксные операторы, как например это делает \textbf{Agda}. Ниже приведен пример определения типа данных списков фиксированной длины(векторов):

\begin{listing}[H]
  \begin{minted}[frame=lines, linenos]{text}
    \data Vector (n : Nat) (A : \Type)
      | Vector  zero   A => vnil
      | Vector (suc n) A => \infixr 5 (:^) A (Vector n A)
  \end{minted}
\caption{Пример определения типа данных списков фиксированной длины в \textbf{Vclang}}
\end{listing}

Конструкторы данных и случаи при сопоставлении с образцом(как в определениях функций, так и в конструкции \textbackslash{}case) отделяются прямой чертой |. Вместо знака равенства используется символ =>. Для сопоставления с образцом используется конструкция \textbackslash{}elim и символ <=. Например, определение функции, берущей первый элемент в векторе выглядит следующим образом:

\begin{listing}[H]
  \begin{minted}[frame=lines, linenos]{text}
    \function
    head {n : Nat} {A : \Type0} (xs : Vector (suc n) A) : A <= \elim xs
      | (:^) x _ => x
  \end{minted}
\caption{Пример определения функции взятия первого элемента в векторе в \textbf{Vclang}}
\end{listing}

 Больше примеров можно посмотреть в стандартной библиотеке языка, которая доступна по адресу \url{https://github.com/valis/vclang-lib}

Главное же отличие \textbf{Vclang} состоит в том, как в нем устроено равенство. Напомним, что в \textbf{Agda} тип-равенство определяется как тип с единственным конструктором:

\begin{listing}[H]
  \begin{minted}[frame=lines, escapeinside=||, linenos]{haskell}
    infix 1 _|$\equiv$|_
    data _|$\equiv$|_ {A : Set} (a : A) : A |$\to$| Set where
      refl : a |$\equiv$| a
  \end{minted}
\caption{Определение типа-равенства в \textbf{Agda}}
\end{listing}

О типе $a \equiv b$ можно в таком случае думать, как об утверждении, что $a$ равен $b$. Доказательством этого утверждения будет терм \mintinline{haskell}{refl}. Так как \mintinline{haskell}{refl} является конструктором, то мы можем использовать сопоставление с образцом. Таким образом можно, например, доказывать свойства равенства:

\begin{listing}[H]
  \begin{minted}[frame=lines, escapeinside=||, linenos]{haskell}
    sym : {A : Set} {a a' : A} |$\to$| a |$\equiv$| a' |$\to$| a' |$\equiv$| a
    sym refl = refl
  \end{minted}
  \caption{Доказательство симметричности равенства в \textbf{Agda}}
\end{listing}

В \textbf{Vclang} равенство определяется с помощью так называемых <<путей>>. Формально эта теория вводится в статье~ \cite{isaev2016model}, здесь же мы просто скажем, что тип-равенство определяется как функция над специальным типом $I$(от слова <<interval>>). Все свойства равенства(рефлексивность, симметричность и т.д), соответственно, определяются как функции над путями. Похожим образом равенство определяется в кубической теории типов, описанной в работе~\cite{cohen2016cubical}.

Вторым отличием \textbf{Vclang} являются типы данных с условиями. Поясним на небольшом примере. Пусть у нас есть тип натуральных чисел \mintinline{text}{Nat}. Мы хотим определить тип целых чисел, как тип с двумя конструкторами: первый описывает положительные числа, второй -- отрицательные.

\begin{listing}[H]
  \begin{minted}[frame=lines, linenos]{text}
    \data Int
      | pos Nat
      | neg Nat
  \end{minted}
  \caption{Тип целых чисел. Вариант 1}
\end{listing}

У этого определения есть одна проблема -- мы получили два нуля. Один со знаком плюс, второй -- со знаком минус. Эту проблему очень легко решить. \textbf{Vclang} позволяет написать условие, которое говорит, как вычисляются конструкторы. Например:

\begin{listing}[H]
  \begin{minted}[frame=lines, linenos]{text}
    \data Int
      | pos Nat
      | neg Nat
    \with
      | neg zero => pos zero
  \end{minted}
  \caption{Тип целых чисел с условием}
\end{listing}

Ключевое слово \textbackslash{}with означает, что выражение, стоящее слева от знака => вычисляется в выражение, стоящее справа.

В языках программирования существуют различные конструкции, которые в том или ином роде моделируют фактор-множества. Самый простой способ сделать это -- переопределить операцию сравнения на типе. В системе автоматического доказательства теорем \textbf{Agda} аналогом фактор-множеств являются так называемые \textit{сетоиды} -- множества с введенным на них отношением эквивалентности. Технически, они устроены, как записи из подлежащего типа и отношения. В \textbf{Isabelle} также есть фактор-типы, но устроены они несколько иным, довольно запутанным образом.

В \textbf{Coq} есть некоторая поддержка фактор-типов, реализованная, согласно работе~\cite{cohen2013pragmatic} с помощью библиотеки-расширения \textbf{SSReflect}. Однако, есть и более ранняя работа~\cite{chicli2002mathematical}, в которой авторы упоминают о расширении теории типов Calculus Of Constructions фактор-типами и показывают, что такое расширение, если реализовать его в \textbf{Coq} противоречиво.

В нашем случае, можно обойтись и формализовывать именованное представление без фактор-типов и использовать, например, сетоиды, но тогда вместо доказательстве равенства типов(эквивалентности между различными представлениями) нам придется вводить и доказывать отношение эквивалентности сетоидов. Отношение равенства мы считаем более предпочтительным по многим причинам, в частности, для него верен принцип Лейбница(принцип подстановки эквивалентных).

Можно возразить, что в  \textbf{Agda} и \textbf{Coq} так же есть поддержка гомотопической теории типов, но \textbf{Vclang} не просто ее поддерживает -- он построен на ней, именно поэтому мы выбрали его в качестве инструмента для реализации.

Тип интервала в \textbf{Vclang} и типы данных с условиями дают нам возможность элегантно описывать фактор-множества:

\begin{listing}[H]
  \begin{minted}[frame=lines, linenos]{text}
    \truncated \data Quotient (A : \Set) (R : A -> A -> \Prop) : \Set
      | classEq A
      | quotEq (a a' : A) (R a a') I
    \with
      | quotEq a a' p left  => classEq a
      | quotEq a a' p right => classEq a'
  \end{minted}
  \caption{Тип фактор-множества $\faktor{A}{R}$}
\end{listing}

Первый конструктор <<вкладывает>> элемент \mintinline{text}{A} в класс эквивалентности $[a]_{R}$, а второй -- склеивает вместе элементы, которые находятся в отношении $R$.
