\subsection{Описание языка Vclang}

Для реализации всех описанных во второй главе представлений руководителем был предложен язык \textbf{Vclang}. В этом подразделе мы кратко опишем его отличия от известных систем автоматического доказательства теорем, например \textbf{Agda}.

Язык \textbf{Vclang} разрабатывается в компании JetBrains с февраля 2015 года в рамках исследования в группе гомотопической теории типов и зависимых типов\footnote{https://research.jetbrains.org/ru/groups/group-for-dependent-types-and-hott}. Он представляет собой функциональный язык программирования, основанный на гомотопической теории типов с типом интервала. Компилятор языка написан полностью на \textbf{Java}, что позволяет полностью использовать все преимущества платформы \textbf{JVM}, как-то кроссплатформенность, легкость в инструментировании и возможность разрабатывать модули на языках программирования, совместимых с платформой \textbf{JVM}(например на \textbf{Scala} или \textbf{Kotlin}).

С точки зрения синтаксиса, \textbf{Vclang} очень похож на \textbf{Agda}, кроме использования Unicode-обозначений и позволяет определять и пользоваться многими знакомыми конструкциями, как то:
\begin{enumerate}
  \item Индуктивные типы данных(как и в упрощенном синтаксисе, так и в синтаксисе обобщенных алгебраических типов данных)
  \item Сопоставление с образцом
  \item Метапеременные
  \item Проверка на тотальность
\end{enumerate}

% плохой абзац, подумай, как переписать
Последний пункт означает примерно следующее. Так как задача проверки типа в такой системе должна быть разрешима, то все вычисления в типах должны завершаться. Это, в свою очередь, означает, что все функции, которые определяет программист должны завершаться на всех входах, то есть быть тотальными. Проверка на тотальность и означает, что среди прочих особенностей, в языке есть компонент, который проверяет, действительно ли все функции завершаются на всех входах. Это приводит к тому, что конструкции приходится определять так, чтобы вычислителю было очевидно, что они завершаются. При этом с точки зрения программиста, эти конструкции из простых и понятных могут превратиться в неочевидные.

Главное же отличие \textbf{Vclang} состоит в том, как в нем устроено равенство. Напомним, что в \textbf{Agda} тип-равенство определяется как тип с единственным конструктором:

\begin{listing}[H]
  \begin{minted}[frame=lines, escapeinside=||, linenos]{haskell}
    infix 1 _|$\equiv$|_
    data _|$\equiv$|_ {A : Set} (a : A) : A |$\to$| Set where
      refl : a |$\equiv$| a
  \end{minted}
\caption{Определение типа-равенства в \textbf{Agda}}
\end{listing}

О типе $a \equiv b$ можно в таком случае думать, как об утверждении, что $a$ равен $b$. Доказательством этого утверждения будет терм \mintinline{haskell}{refl}. Так как \mintinline{haskell}{refl} является конструктором, то мы можем использовать сопоставление с образцом. Таким образом можно, например, доказывать свойства равенства:

\begin{listing}[H]
  \begin{minted}[frame=lines, escapeinside=||, linenos]{haskell}
    sym : {A : Set} {a a' : A} |$\to$| a |$\equiv$| a' |$\to$| a' |$\equiv$| a
    sym refl = refl
  \end{minted}
  \caption{Доказательство симметричности равенства в \textbf{Agda}}
\end{listing}

В \textbf{Vclang} равенство определяется с помощью так называемых <<путей>>. Формально эта теория вводится в статье~ \cite{isaev2016model}, здесь же мы просто скажем, что тип-равенство определяется как функция над специальным типом $I$(от слова <<interval>>). Все свойства равенства(рефлексивность, симметричность и т.д), соответственно, определяются как функции над путями. Похожим образом равенство определяется в кубической теории типов, описанной в работе~\cite{cohen2016cubical}.

Вторым отличием \textbf{Vclang} являются типы данных с условиями. Поясним на небольшом примере. Пусть у нас есть тип натуральных чисел \mintinline{text}{Nat}. Мы хотим определить тип целых чисел, как тип с двумя конструкторами: первый описывает положительные числа, второй -- отрицательные.

\begin{listing}[H]
  \begin{minted}[frame=lines, linenos]{text}
    \data Int
      | pos Nat
      | neg Nat
  \end{minted}
  \caption{Тип целых чисел. Вариант 1}
\end{listing}

У этого определения есть одна проблема -- мы получили два нуля. Один со знаком плюс, второй -- со знаком минус. Эту проблему очень легко решить. \textbf{Vclang} позволяет написать условие, которое говорит, как вычисляются конструкторы. Например:

\begin{listing}[H]
  \begin{minted}[frame=lines, linenos]{text}
    \data Int
      | pos Nat
      | neg Nat
    \with
      | neg zero => pos zero
  \end{minted}
  \caption{Тип целых чисел с условием}
\end{listing}

Тип интервала и типы данных с условиями дают нам возможность элегантно описывать фактор-множества:

\begin{listing}[H]
  \begin{minted}[frame=lines, linenos]{text}
    \truncated \data Quotient (A : \Set) (R : A -> A -> \Prop) : \Set
      | classEq A
      | quotEq (a a' : A) (R a a') I
    \with
      | quotEq a a' p left  => classEq a
      | quotEq a a' p right => classEq a'
  \end{minted}
  \caption{Тип фактор-множества $\faktor{A}{R}$}
\end{listing}

Первый конструктор <<вкладывает>> элемент \mintinline{text}{A} в класс эквивалентности $[a]_{R}$, а второй -- склеивает вместе элементы, которые находятся в отношении $R$. Аналогом этой конструкции в \textbf{Agda} являются \textit{сетоиды} -- множества с введенным на них отношением эквивалентности. В нашем случае, можно обойтись и формализовывать именованное представление без фактор-типов и использовать сетоиды, но тогда вместо доказательстве равенства типов(эквивалентности между различными представлениями) нам придется вводить и доказывать отношение эквивалентности сетоидов. Отношение равенства предпочтительней по многим причинам, в частности, для него верен принцип Лейбница(принцип подстановки эквивалентных).
