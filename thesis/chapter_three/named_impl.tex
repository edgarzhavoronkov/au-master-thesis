\subsection{Реализация именованного представления термов}

Термы в этом представлении кодируются следующим типом данных:
\begin{listing}[H]
  \begin{minted}[breaklines=true, frame=lines, linenos]{text}
    -- N is for named
    \data NTerm
        | NVar Nat
        | NApp NTerm NTerm
        | NLam Nat NTerm
  \end{minted}
  \caption{Тип данных, кодирующий термы в именованном представлении.}
\end{listing}

Сразу же отметим, что в имена переменных мы берем из множества натуральных чисел. Мы делаем это по ряду причин. Во-первых, в языке бедная стандартная библиотека и символов в ней нет. Во-вторых, в описании именованного представления в разделе~\ref{sec:named} мы неявно предполагаем, что на множестве $\mathcal{V}$ равенство разрешимо. В дальнейшем, мы пользуемся им для определения, например, операции подстановки.

Альфа-эквивалентность определяется как следующий индуктивный предикат:
\begin{listing}[H]
  \begin{minted}[breaklines=true, frame=lines, linenos]{text}
    \data AlphaEq (t1 t2 : NTerm)
      | AlphaEq (NVar x) (NVar y)           => VarEq (x = y)
      | AlphaEq (NApp t1 s1) (NApp t2 s2)   => AppEq (AlphaEq t1 t2) (AlphaEq s1 s2)
      | AlphaEq (NLam x t1) (NLam y t2)     => LamEq (b : Nat) (b != x) (b != y) (b # t1) (b # t2) (AlphaEq (nsubst-var t1 x b) (nsubst-var t2 y b))
  \end{minted}
  \caption{Определение альфа-эквивалентности.}
\end{listing}

Обратим внимание на случай абстракции. Можно было бы определить его проще, как в разделе~\ref{sec:named}, но то определение имеет ряд недостатков. Предположим, что мы хотели бы доказать рефлексивность альфа-эквивалентности. В случае абстракции нам бы понадобилось свойство унитальности для подстановки. Но в доказательстве свойства унитальности так же используется рефлексивность. Получается своеобразная цепочка взаимно-рекурсивных определений, завершаемость которой крайне неочевидна для языка.

Здесь предикат \mintinline{text}{x # t} означает, что переменная \mintinline{text}{x} является <<свежей>> для терма \mintinline{text}{t}, то есть не встречается в списке переменных этого терма.

Операция подстановки могла бы быть определена следующим образом:
\begin{listing}[H]
  \begin{minted}[breaklines=true, frame=lines, linenos]{text}
    \function
    nsubst
        (t : NTerm)
        (y : Nat)
        (s : NTerm) : NTerm <= \elim t
            | NVar x     => \case x =? y | inr _ => s | inl _ => (NVar x)
            | NApp t1 t2 => NApp (nsubst t1 y s) (nsubst t2 y s)
            | NLam x t   => \let
                              | frv => gen-fresh-var t
                            \in \case isFreeDec x s | inr _ => (NLam frv (nsubst (nsubst t x (NVar frv)) y s)) | inl _ => (NLam x (nsubst t y s))
  \end{minted}
  \caption{Один из вариантов определения операции подстановки.}
\end{listing}

К сожалению и этот вариант не проходит проверку на завершаемость в случае лямбда-абстракции. Отметим, что и в разделе~\ref{sec:named} в доказательстве леммы о подстановке мы весьма небрежно использовали индукционную гипотезу. Для неформальных рассуждений это еще допустимо, но для строго формальных -- уже нет. Чтобы решить эту проблему, мы определили более общий случай подстановки -- параллельную подстановку:

\begin{listing}[H]
  \begin{minted}[breaklines=true, frame=lines, linenos]{text}
    \function
    nsubst'
        (t : NTerm)
        (ps : List (\Sigma Nat NTerm)) : NTerm <= \elim t
            | NVar x        => lookup ps x
            | NApp t1 t2    => NApp (nsubst' t1 ps) (nsubst' t2 ps)
            | NLam x t      =>  \let
                                    | ts => (NLam x t) :-: (map (\lam (p : \Sigma Nat NTerm) => p.2) ps)
                                    | x' => gen-fresh-var ts
                                \in NLam x' (nsubst' t ((x, NVar x') :-: ps))


    \function
    nsubst
        (t : NTerm)
        (y : Nat)
        (s : NTerm) : NTerm => nsubst' t (singleton (y, s))
  \end{minted}
  \caption{Вариант определения операции подстановки с помощью параллельной подстановки.}
\end{listing}

Этот вариант уже, очевидно, завершается. Однако доказательство леммы о подстановке все еще представляет большие трудности из-за того, что необходимо рассматривать большое количество случаев и конструкции в типах становятся громоздкими. Один из способов решить эту проблему -- использовать идеи, аналогичные тем, что применяются в номинальных множествах -- \cite{pitts2013nominal}.

\begin{enumerate}
  \item Про преобразование
  \item ОЧЕНЬ АККУРАТНО сказать про то, что лемма о подстановке довольно нетривиальное утверждение для формального доказательства. Неформально, мы доказали ее, крайне небрежно используя индукционную гипотезу. Если бы мы писали такое доказательство в нашей системе, то было бы неочевидно, что оно завершается. Поэтому работу хотелось бы закончить на проблемах, с которыми пришлось столкнуться.
\end{enumerate}
