\subsection{Реализация неименованного представления термов}

Как уже упоминалось в разделах~\ref{sec:lambda} и~\ref{sec:index}, неименованное представление удобно для компьютерной реализации, так как, в частности, проверка термов на $\alpha$-эквивалентность сводится к обычной проверке на равенство. Ниже приведен пример определения типа данных для термов в данном представлении:

\begin{listing}[H]
  \begin{minted}[breaklines=true, frame=lines, linenos]{text}
    -- I is for index
    \data ITerm (n : Nat)
      | IVar (Fin n)
      | IApp (ITerm n) (ITerm n)
      | ILam (ITerm (suc n))
  \end{minted}
  \caption{Тип данных, кодирующий термы в неименованном представлении.}
\end{listing}

Здесь \mintinline{text}{Fin n} -- это тип конечных множеств на $n$ элементов. О них можно думать как о множествах $\overline{n} = \{0,1, \dots, n-1\}$.

Единственный тонкий момент, связанный с реализацией этого представления -- это преобразование неименованных термов в именованные. Если определять его напрямую, как описывалось в разделе~\ref{sec:index}, то уже в случае аппликации выяснится несоответствие типов. Рассмотрим пример:

\begin{listing}[H]
  \begin{minted}[breaklines=true, frame=lines, linenos]{text}
    \function
    psi
      {n : Nat}
      (t : ITerm n) : \Sigma (env : Ctx n) (t' : NTerm) (proof : TermInCtx env t') <= \elim t
        | IVar i       =>  (gen_env n, NVar (env !! i), VarInCtx (i, idp))
        | IApp s1 s2   =>  ((psi s1).1, NApp ((psi s1).2) ((psi s2).2), AppInCtx ((psi s1).3) {?})
        | ILam t       =>  (rtail ((psi t).1), NLam (rhead ((psi t).1)) ((psi t).2), LamInCtx (transport (\lam a => TermInCtx a t') (inv (snoc-lemma ((psi t).1))) ((psi t).3)))
  \end{minted}
  \caption{Вариант определения функции, переводящей неименованный терм в именованный.}
\end{listing}

Мы хотим вернуть доказательство того, что аппликация \mintinline{text}{NApp t1 t2} определена в контексте \mintinline{text}{env1}, для этого нам, очевидно, нужны доказательства, что оба аппликанта определены в \mintinline{text}{env1}. Для первого аппликанта оно естественным образом получается из рекурсивного вызова. Для второго же мы моежм только получить доказательство,  что \mintinline{text}{t2}  определен в контексте \mintinline{text}{env2}.

Чтобы решить эту проблему заметим, что нам не очень важно, в каком контексте будет определен получившийся на выходе терм. Поэтому мы можем поступить иначе. Мы определим вспомогательную функцию, которая будет принимать на вход контекст и возвращать пару из терма и доказательства, что он определен в этом контексте. Тогда основная функция будет генерировать контекст заданной длины и вызывать от него вспомогательную. Например:

\begin{listing}[H]
  \begin{minted}[breaklines=true, frame=lines, linenos]{text}
    \function
    psi'
        {n : Nat}
        (env : Ctx n)
        (t : ITerm n) : \Sigma (t' : NTerm) (p : TermInCtx env t') <= \elim t
            | IVar i        => (NVar (env !! i), VarInCtx (i, idp))
            | IApp t1 t2    => (NApp (psi' env t1).1 (psi' env t2).1, AppInCtx (psi' env t1).2 (psi' env t2).2)
            | ILam t        => (NLam n (psi' (extend env n) t).1, LamInCtx (psi' (extend env n) t).2)


    \function
    psi
        {n : Nat}
        (t : ITerm n) : \Sigma (env : Ctx n) (t' : NTerm) (proof : TermInCtx env t') => (gen_env n, (psi' (gen_env n) t).1, (psi' (gen_env n) t).2)
  \end{minted}
  \caption{Вариант определения функции, переводящей неименованный терм в именованный, не вызывающий ошибки проверки типов.}
\end{listing}
