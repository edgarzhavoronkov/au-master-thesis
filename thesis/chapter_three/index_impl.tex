\subsection{Реализация неименованного представления термов}

Как уже упоминалось в разделах~\ref{sec:lambda} и~\ref{sec:index}, неименованное представление удобно для компьютерной реализации, так как, в частности, проверка термов на $\alpha$-эквивалентность сводится к обычной проверке на равенство. Ниже приведен пример определения типа данных для термов в данном представлении:

\begin{listing}[H]
  \begin{minted}[frame=lines, linenos]{haskell}
    -- I is for index
    \data ITerm (n : Nat)
      | IVar (Fin n)
      | IApp (ITerm n) (ITerm n)
      | ILam (ITerm (suc n))
  \end{minted}
  \caption{Тип данных, кодирующий термы в неименованном представлении.}
\end{listing}

Здесь \mintinline{haskell}{Fin n} -- это тип конечных множеств на $n$ элементов. О них можно думать как о множествах $\overline{n} = \{0,1, \dots, n-1\}$.

Единственный тонкий момент, связанный с реализацией этого представления -- это преобразование неименованных термов в именованные. Если определять его напрямую, как описывалось в разделе~\ref{sec:index}, то уже в случае аппликации выяснится несоответствие типов. Рассмотрим пример:

\begin{listing}[H]
  \begin{minted}[breaklines=true, frame=lines, linenos]{haskell}
    \function
    psi
      {n : Nat}
      (t : ITerm n) : \Sigma (env : Ctx n) (t' : NTerm) (proof : TermInCtx env t') <= \elim t
        | IVar i       =>  \let
                              | env => gen_env n
                              | var => env !! i
                            \in (env, NVar var, VarInCtx (i, idp))
        | IApp s1 s2   =>  \let
                              | res1  => psi s1
                              | res2  => psi s2
                              | env1  => res1.1
                              | env2  => res2.1
                              | t1    => res1.2
                              | t2    => res2.2
                              | pr1   => res1.3
                              | pr2   => res2.3
                            \in (env1, NApp t1 t2, AppInCtx pr1 {?})
        | ILam t       =>  \let
                              | res => psi t
                              | env => res.1
                              | t'  => res.2
                              | p   => res.3
                              | x   => rhead env
                              | xs  => rtail env
                              | pr  => transport (\lam a => TermInCtx a t') (inv (snoc-lemma env)) p
                            \in (xs, NLam x t', LamInCtx pr)
  \end{minted}
  \caption{Вариант определения функции, переводящей неименованный терм в именованный.}
\end{listing}

Мы хотим вернуть доказательство того, что аппликация \mintinline{haskell}{NApp t1 t2} определена в контексте \mintinline{haskell}{env1}, для этого нам, очевидно, нужны доказательства, что оба аппликанта определены в \mintinline{haskell}{env1}. Для первого аппликанта оно естественным образом получается из рекурсивного вызова. Для второго же мы моежм только получить доказательство,  что \mintinline{haskell}{t2}  определен в контексте \mintinline{haskell}{env2}.

Чтобы решить эту проблему заметим, что нам не очень важно, в каком контексте будет определен получившийся на выходе терм. Поэтому мы можем поступить иначе. Мы определим вспомогательную функцию, которая будет принимать на вход контекст и возвращать пару из терма и доказательства, что он определен в этом контексте. Тогда основная функция будет генерировать контекст заданной длины и вызывать от него вспомогательную. Например:

\begin{listing}[H]
  \begin{minted}[breaklines=true, frame=lines, linenos]{haskell}
    \function
    psi'
        {n : Nat}
        (env : Ctx n)
        (t : ITerm n) : \Sigma (t' : NTerm) (p : TermInCtx env t') <= \elim t
            | IVar i        => (NVar (env !! i), VarInCtx (i, idp))
            | IApp t1 t2    => (NApp (psi' env t1).1 (psi' env t2).1, AppInCtx (psi' env t1).2 (psi' env t2).2)
            | ILam t        => (NLam n (psi' (extend env n) t).1, LamInCtx (psi' (extend env n) t).2)


    \function
    psi
        {n : Nat}
        (t : ITerm n) : \Sigma (env : Ctx n) (t' : NTerm) (proof : TermInCtx env t') => (gen_env n, (psi' (gen_env n) t).1, (psi' (gen_env n) t).2)
  \end{minted}
  \caption{Вариант определения функции, переводящей неименованный терм в именованный, не вызывающий ошибки проверки типов.}
\end{listing}

% Примерный план того, что здесь будет:
% \begin{enumerate}
%   \item Тип данных для термов
%   \item Сказать о том, что это представление довольно удобно для реализации, все, что мы описали во второй главе перекладывается на код и почти ничего не надо менять
%   \item Рассказать, что если мы захотим переводить эти термы в именованные, то там есть трюк. Заключается он в том, что нам не важно в каком контексте определен результат, поэтому мы можем сгенерировать его и дать его на вход функции, а та уже сконструирует терм, определенный в поданном контексте
% \end{enumerate}
